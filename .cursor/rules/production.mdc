---
description: 
globs: 
alwaysApply: true
---
# Comprehensive Cursor Rules for Web3 dApp Production Environments

## Primary Directives

1. **ENGLISH RESPONSES ONLY**: All communications, code suggestions, and documentation must be exclusively in English.

2. **NO TOAST NOTIFICATIONS**: Under no circumstances are toast notifications to be implemented or suggested. These are strictly prohibited as they introduce unnecessary UI elements and potential interruptions to the workflow.

3. **PRODUCTION ENVIRONMENT PROTOCOLS**: All code is being implemented in a live production environment connected to real blockchain networks with real assets, not a test, mock, simulation, or development environment. Exercise maximum caution.

4. **MAINNET-FIRST SECURITY**: Always implement code with the assumption that it will interact with mainnet value, even in development environments.

5. **IRREVERSIBLE TRANSACTION AWARENESS**: Maintain constant awareness that blockchain transactions are generally irreversible, and errors can result in permanent loss of funds.

6. **MULTI-CHAIN COMPATIBILITY**: Ensure all implementations consider the specific requirements and behaviors of each supported blockchain network.

## Code Integrity Guidelines

1. **VERIFICATION REQUIREMENT**: All code suggestions must be thoroughly verified for syntax correctness, logical consistency, and adherence to the existing codebase architecture before submission, with special attention to blockchain-specific syntax requirements.

2. **NO MOCK IMPLEMENTATIONS**: Do not create or suggest mock implementations, placeholder functions, or simulation code. All code must be production-ready and fully functional, particularly for wallet interactions and transaction signing flows.

3. **NO CODE COMMENTS**: Do not add comments to the codebase. The code must be self-documenting and clear enough to stand without explanatory comments, even for complex Web3 operations.

4. **NO SIMULATIONS**: Do not simulate code execution or effects. Only provide code that is guaranteed to execute properly in the production environment with real blockchain interactions.

5. **SOLIDITY VERSION CONSISTENCY**: Maintain consistent Solidity compiler version usage across all smart contracts.

6. **INHERITANCE HIERARCHY PRECISION**: Ensure proper inheritance order and super calls in smart contract extensions.

7. **INTERFACE COMPLIANCE**: Strictly adhere to interface definitions when implementing contract functionality.

8. **DECIMALS AND PRECISION HANDLING**: Implement proper decimal handling for token values and financial calculations with appropriate precision management.

## Implementation Standards

1. **PRECISION MANDATE**: Every character, whitespace, indent, and line break must be deliberately placed and verified. Imprecise code poses critical risks in production, especially in smart contracts where syntax errors can lead to catastrophic fund loss.

2. **COMPREHENSIVE SOLUTIONS**: Provide complete solutions that address the entire scope of the requirement without fragmentary implementations, ensuring full transaction lifecycle handling.

3. **CONTEXTUAL AWARENESS**: All suggestions must demonstrate awareness of the surrounding codebase context, architectural patterns, and established conventions, including Web3 design patterns.

4. **ERROR HANDLING REQUIREMENT**: All code must include robust error handling mechanisms appropriate for production environments, including graceful failure processes and transaction reversion handling.

5. **ASYNCHRONOUS TRANSACTION HANDLING**: Implement proper handling of blockchain transaction lifecycles, including pending, confirmed, and failed states.

6. **CHAIN-SPECIFIC CONSIDERATIONS**: Account for chain-specific behaviors, gas estimation methods, and RPC endpoint requirements.

7. **PROPER BIGINT HANDLING**: Always use appropriate libraries for handling large integers and decimals common in token amounts and blockchain values.

8. **TRANSACTION BATCHING OPTIMIZATION**: Where appropriate, implement transaction batching to reduce gas costs and improve user experience.

## Security Protocols

1. **VULNERABILITY ASSESSMENT**: All code must be assessed for potential security vulnerabilities before submission, with particular attention to Web3-specific attack vectors.

2. **AUTHENTICATION PRESERVATION**: Never compromise existing authentication mechanisms or security measures, including wallet connection protocols and signature verification processes.

3. **DATA INTEGRITY PROTECTION**: Ensure all data transformations maintain integrity and follow established validation protocols, especially for blockchain transaction data.

4. **NO HARDCODED CREDENTIALS**: Never suggest implementations with hardcoded credentials, API keys, private keys, seed phrases, or other sensitive information.

5. **REENTRANCY PROTECTION**: All smart contract interactions must implement safeguards against reentrancy attacks and follow the checks-effects-interactions pattern.

6. **ORACLE MANIPULATION RESISTANCE**: Implement proper safeguards against price oracle manipulation and timestamp dependencies.

7. **FRONT-RUNNING MITIGATION**: Consider and implement appropriate protections against MEV and front-running attacks where applicable.

8. **ACCESS CONTROL PRECISION**: Implement rigorous access control mechanisms for privileged functions in smart contracts and backend services.

## Performance Considerations

1. **RESOURCE EFFICIENCY**: All code must be optimized for minimal resource consumption appropriate to its function, with special attention to on-chain operations where computational costs are directly translated to financial costs.

2. **SCALABILITY REQUIREMENT**: Implementations must accommodate potential scaling requirements without architectural refactoring, considering both blockchain and application-level scaling.

3. **LATENCY MINIMIZATION**: Code must minimize additional latency introduced to system operations, implementing optimistic UI patterns where appropriate for blockchain operations.

4. **GAS OPTIMIZATION**: Smart contract code must be optimized for gas efficiency using established patterns like storage packing, memory usage optimization, and minimal on-chain storage.

5. **RPC PROVIDER MANAGEMENT**: Implement proper load balancing, fallback mechanisms, and rate limiting for RPC provider interactions.

6. **CACHING STRATEGIES**: Utilize appropriate caching strategies for blockchain data to minimize redundant RPC calls while maintaining data freshness.

7. **INDEXING SERVICES INTEGRATION**: Where appropriate, leverage specialized indexing services like The Graph for efficient data retrieval instead of direct blockchain queries.

8. **TRANSACTION SIMULATION**: Implement pre-flight transaction simulation where possible to prevent failed transactions and wasted gas fees.

## Testing Implications

1. **TESTABILITY MANDATE**: While not implementing tests directly, code must be structured to facilitate comprehensive testing by development teams, including unit tests, integration tests, and blockchain-specific testing frameworks.

2. **EDGE CASE CONSIDERATION**: All implementations must account for documented edge cases and potential failure scenarios, including network congestion, chain reorganizations, failed transactions, and gas price volatility.

3. **FORK TESTING PREPARATION**: Structure code to enable testing on forked networks that simulate production blockchain state.

4. **DETERMINISTIC BEHAVIOR**: Ensure consistent and deterministic behavior in smart contract code to facilitate predictable testing outcomes.

5. **FORMAL VERIFICATION READINESS**: Where critical, structure code to facilitate formal verification of smart contract logic.

6. **SIMULATION ENVIRONMENT COMPATIBILITY**: Ensure code works with simulation environments like Hardhat, Foundry, or Ganache for local testing.

7. **TESTNET COMPATIBILITY**: Maintain compatibility with relevant testnets for each supported blockchain.

8. **FUZZING PREPAREDNESS**: Structure code to withstand property-based and fuzzing tests that provide random or boundary-case inputs.

## Documentation Standards

1. **CLARITY IMPERATIVE**: All explanations must be clear, concise, and technically precise, using established Web3 terminology consistently.

2. **IMPLEMENTATION RATIONALE**: When appropriate, provide concise rationale for implementation decisions that impact system architecture, especially for gas optimization strategies and security measures.

3. **NO AMBIGUITY**: Avoid ambiguous terminology or instructions that could result in misinterpretation, particularly for transaction flows and state changes.

4. **ADDRESS AND HASH FORMATTING**: Always clearly identify the blockchain network when referencing addresses, transaction hashes, or block numbers.

5. **INTERFACE SPECIFICATIONS**: Provide clear ABI specifications and interface definitions for smart contract interactions.

6. **EVENT DOCUMENTATION**: Thoroughly document all emitted events and their parameters for frontend integration.

7. **STATE TRANSITION DOCUMENTATION**: Clearly document all possible state transitions in smart contracts and their effects.

8. **SECURITY CONSIDERATIONS**: Explicitly document security assumptions and potential attack vectors that have been mitigated.

9. **GAS ESTIMATION GUIDANCE**: Provide guidance on expected gas costs for on-chain operations under various network conditions.

## Web3 & Blockchain-Specific Requirements

1. **SMART CONTRACT INTEGRITY**: All smart contract code must be treated with maximum caution. A single error can result in catastrophic financial loss and is often irreversible.

2. **GAS OPTIMIZATION IMPERATIVE**: All on-chain transactions and smart contract functions must be optimized for minimal gas consumption without compromising security.

3. **WALLET INTEGRATION PRECISION**: Wallet connection code must handle all potential states including disconnection, network switching, and signature requests with proper error handling.

4. **BLOCKCHAIN FINALITY AWARENESS**: Never assume transaction finality without proper confirmation mechanisms appropriate to the specific blockchain being used.

5. **CRYPTOGRAPHIC VERIFICATION**: All cryptographic functions, signatures, and hash validations must be implemented with proven libraries and verified for correctness.

6. **MAINNET/TESTNET DISTINCTION**: Always maintain absolute clarity about whether code is targeting mainnet or testnet environments, with appropriate safeguards against cross-environment confusion.

7. **STATE MANAGEMENT RIGOR**: Implement robust state management for blockchain interactions, accounting for pending transactions, confirmations, and chain reorganizations.

8. **NO HARDCODED ADDRESSES**: Never hardcode wallet addresses, contract addresses, or network identifiers. These should be properly parameterized and configured.

9. **CROSS-CHAIN COMPATIBILITY**: When implementing multi-chain functionality, ensure proper chain ID validation and network-specific behavior handling.

10. **EVENT HANDLING COMPLETENESS**: Implement comprehensive event listeners for all relevant blockchain events with proper error and edge case handling.

## Final Verification

1. **FULL REVIEW REQUIREMENT**: All code must undergo a comprehensive review process before submission.

2. **CONFIRMATION OF PRODUCTION READINESS**: Explicitly confirm that the code is suitable for immediate deployment to production without additional modifications.

3. **SECURITY AUDIT READINESS**: Ensure code follows security best practices that would pass a professional smart contract audit.

## Absolute Prohibitions

1. **NO EXPERIMENTAL FEATURES**: Do not implement or suggest experimental, beta, or deprecated features, especially for core blockchain interactions or cryptographic functions.

2. **NO UNNECESSARY DEPENDENCIES**: Do not introduce new dependencies unless absolutely essential, and only use well-audited libraries for cryptographic and blockchain operations.

3. **NO BREAKING CHANGES**: Do not introduce changes that could break existing functionality, especially in smart contract interfaces that must maintain backward compatibility.

4. **NO ASSUMPTIONS**: Do not make assumptions about blockchain state, network conditions, or gas prices. Always implement proper checks and fallbacks.

5. **NO PARTIAL IMPLEMENTATIONS**: Do not suggest partial or incomplete implementations that require additional work to function correctly, especially for critical transaction flows.

6. **NO UNVERIFIED CONTRACTS**: Never interact with unverified smart contracts or suggest integrations with protocols that have not undergone security audits.

7. **NO FLOATING PRAGMA**: Always specify exact compiler versions for smart contracts to ensure consistent behavior across environments.

8. **NO ON-CHAIN LOOPS**: Never implement unbounded loops in smart contract code that could exceed block gas limits.

9. **NO UNCHECKED USER INPUT**: Never trust user input or blockchain data without proper validation and sanitization.

10. **NO CENTRALIZATION POINTS**: Avoid introducing single points of failure or centralized control mechanisms without explicit approval.

## Communication Protocol

1. **VERIFICATION QUERIES**: When essential information is missing, request specific clarification rather than making assumptions, especially regarding blockchain networks, contract addresses, and wallet integration methods.

2. **CONFIRMATION REQUIREMENT**: Request explicit confirmation before implementing changes with significant system impact or that involve irreversible blockchain operations.

3. **PRECISION IN TERMINOLOGY**: Use precise technical terminology from Web3 and blockchain development to avoid miscommunication, clearly differentiating between on-chain and off-chain operations.

4. **BLOCKCHAIN SPECIFICITY**: Always specify the exact blockchain network (e.g., Ethereum mainnet, Polygon, Avalanche C-Chain) when discussing network-specific implementations.

5. **VERSION TRANSPARENCY**: Clearly communicate library versions, contract versions, and protocol versions when implementing integrations.

6. **SECURITY IMPLICATIONS DISCLOSURE**: Explicitly communicate security implications of implementation choices, especially regarding privileged operations and funds management.

REMEMBER: You are working in a LIVE PRODUCTION ENVIRONMENT with REAL DIGITAL ASSETS AND FINANCIAL VALUE. These rules are not optional - they are MANDATORY SAFEGUARDS to prevent critical system failures and potential financial loss.